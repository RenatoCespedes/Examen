<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script> -->
    <!-- <script src="https://threejs.org/examples/js/loaders/FBXLoader.js"></script> -->
    <!--<script src="three.min.js"> </script> 
    <script src="OrbitControls.js"> </script> 
    <script src="dat.gui.min.js"></script>
    -->
    <!-- <script src="three.min.js"> </script> -->
    <script type='module'>     
        import * as THREE from './jsm/three.module.js';
        // import * as FB from './jsm/three.fbx.js';
        import { GUI } from './jsm/dat.gui.module.js';
        import {OrbitControls} from './jsm/OrbitControls.js';
        import {OBJLoader} from './jsm/OBJLoader.js';
        import {STLLoader} from './jsm/STLLoader.js';
        import {MTLLoader} from './jsm/MTLLoader.js';
        import {FBXLoader} from './jsm/fbxLoader.js';

        // utilizado cuando queremos poner la lampara dentro de la scene como un mesh
        // function makeXYZGUI(gui, vector3, name, onChangeFn) {
        //     const folder = gui.addFolder(name);
        //     folder.add(vector3, 'x', -20, 20).onChange(onChangeFn);
        //     folder.add(vector3, 'y', 0, 20).onChange(onChangeFn);
        //     folder.add(vector3, 'z', -20, 20).onChange(onChangeFn);
        //     folder.open();
        // }      

        // utilizado por GUI para modificar los parametros de light en la scena
        // class ColorGUIHelper {
        //     constructor(object, prop) {
        //         this.object = object;
        //         this.prop = prop;
        //     }
        //     get value() {
        //         return `#${this.object[this.prop].getHexString()}`;
        //     }
        //     set value(hexString) {
        //         this.object[this.prop].set(hexString);
        //     }
        // }

        // camera //////////////////////////////////////////////////
        var aspect = window.innerWidth/window.innerHeight;
        // var camera = new THREE.PerspectiveCamera(70, aspect);
        const camera = new THREE.PerspectiveCamera( 60, aspect );
        camera.position.set(10, 70, 120);
        
        // scene //////////////////////////////////////////////////
        var scene = new THREE.Scene();

        // var texture_galaxy= new THREE.TextureLoader().load('textures/galaxy.png');
        // scene.background =  new THREE.Color( 0xffffff );
        // new THREE.TextureLoader().load('textures/galaxy.png');
        
        // const transformation = new THREE.Matrix4 () ;
        // transformation.set (
        // 1, 0, 0, 0,
        // 0, 1, 0, 0,
        // 0, 0, 1, 0,
        // 0, 0, 0, 1
        // );     
        
        // const transformation2 = new THREE.Matrix4 () ;
        // transformation2.set (
        // 1, 0, 0, 0,
        // 1, 1, 0, 0,
        // 1, 0, 1, 0,
        // 1, 0, 0, 1
        // );   


        // var animate = function() {
        // requestAnimationFrame( animate );
        // mesh.geometry.applyMatrix4(transformation );
        // renderer.render( scene , camera );
        // }

        // const new_transformation = transformation.multiply(transformation2);
        // console.log(new_transformation);      
        
       

        // objloader////////////////////////////////////////////////    
        //////////////////////////////////////////////////////////// 
        // const geometry = new THREE.SphereGeometry( 1, 64, 64 );
        // const material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
        // const sphere = new THREE.Mesh( geometry, material );
        // sphere.position.set(0, 0,0);
        // scene.add(sphere);



        // const geometry1 = new THREE.SphereGeometry( 1, 64, 64 );
        // const material1 = new THREE.MeshBasicMaterial( {color: 0xffff00} );
        // const sphere1 = new THREE.Mesh( geometry1, material1 );
        // sphere1.position.set(20, 20,10);
        // scene.add(sphere1);
        

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        class Vec3{
            constructor(x,y,z){
                this.x=x;
                this.y=y;
                this.z=z;
            }
            suma(v2){
                return new Vec3(this.x+v2.x,this.y+v2.y,this.z+v2.z);
            }
            resta(v2){
                return new Vec3(this.x-v2.x,this.y-v2.y,this.z-v2.z);
            }
            multiplicar(v2){
                return this.x*v2.x + this.y+v2.y + this.z+v2.z;
            }
            len3(){
                return this * this;
            }
            len(){
                return Math.sqrt(len3());
            }
            normal(){
                return this/len();
            }
            multFloatClass(b,v2){
                return new Vec3(v2.x*b , v2.y*b , v2.z*b);
            }
        }
        class Neighbor{
            constructor(i,j,q,q2){
                this.i=i;
                this.j=j;
                this.q=q;
                this.q2=q2;
            }
        }
        class Particle{
            constructor(pos,pos_old,vel=new Vec3(),force,mass,rho,rho_near,press,press_near,sigma,beta,neighbors=new Array()){
                this.pos=pos;
                this.pos_old=pos_old;
                this.vel=vel;
                this.force=force;
                this.mass=mass;
                this.rho=rho;
                this.rho_near=rho_near;
                this.press=press;
                this.press_near=press_near;
                this.sigma=sigma;
                this.beta=beta;
                this.neighbors=new Array(40);
            }
            createParticle(){
                const geometry_sphere= new THREE.SphereGeometry();
                // geometry_sphere.vertex.push(new THREE.Vector(new THREE.Vec3(this.pos[0],this.pos[1,this.pos[2]])));
                // geometry_sphere.vertices.push(new THREE.Vector3( 0, 0, 0));
                // geometry_sphere.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                // var textura_water= new THREE.TextureLoader().load('textures/textureWater.png')
                const material= new THREE.PointsMaterial({size:1,color:0x0000ff});
                
                const particula=new THREE.Points(geometry_sphere, material);
                particula.position.set(this.pos.x,this.pos.y,this.pos.z);
                // particula.speed.set(this.vel.x,this.vel.y,this.vel.z);
                scene.add(particula);
                // console.log(particula.vel);
                // planeta.position.set(10,10,0);
                // planeta.userData.orbit=this.orbita;
                particula.userData.speed=this.vel;
                particula.userData.pos_old=this.pos_old;
                particula.userData.pos=this.pos;
                particula.userData.force=this.force;
                particula.userData.mass=this.mas;
                particula.userData.rho=this.rho;
                particula.userData.rho_near=this.rho_near;
                particula.userData.press=this.press;
                particula.userData.press_near=this.press_near;
                particula.userData.sigma=this.sigma;
                particula.userData.beta=this.beta;
                particula.userData.neighbors=[];
                return particula;
            }
        }
       
        //--------------------------------------
        var window_w=512, window_h=512;             // Initial Size of the Window
        var N = 1000;                                       // Number of Particles in the simulation

        var G = .02 * .25;                       // Gravitational Constant for our simulation

        var spacing = 2.0;                            // Spacing of particles
        var k = spacing / 1000.0;            // Far pressure weight
        var k_near = k*10;                            // Near pressure weight
        var rest_density = 3;                     // Rest Density
        var r=spacing*1.25;
        // 1.25;                       // Radius of Support
        var rsq=r*r;                                  // ... squared for performance stuff

        var SIM_W=30;                             // The size of the world
        var bottom = 0; 
        var particles=[];
        var RAND_MAX=1298;
        var vertices=[];

        function rand01() { return Math.random() * (1.0 / RAND_MAX); }

        function randab(a, b) { return a + (b-a)*rand01(); }
        function inicio(){
            
            // const pos_old=[];
            // const vertexVec=[];
            const w=SIM_W/4;
            for(let z=bottom+1;z<20;z+=r*.5){
                for(let y=bottom+1;y<20;y+=r*.5){
                    for(let x=-w;x<=w;x+=r*.5){
                        
                        if(particles.lenght > N){
                            break;
                        }
                        // else if(vertices.length==3){
                        //     vertices=[]
                        // }
                        // vertices.push(x,y,z);
                        // console.log(vertices);
                        var al=new Vec3(rand01(),rand01(),rand01());
                        al=al.multFloatClass(0.001,al);
                        var pos=new Vec3(x,y,z);
                        var pos_old= new Vec3(pos.x+al.x,pos.y+al.y,pos.z+al.z);
                        var p=new Particle(pos,pos_old,new Vec3(0,0,0),new Vec3(0,0,0),0,0,0,0,0,1.,0,[]);
                        // var 
                        var pp=p.createParticle();
                        // scene.add(pp);
                        particles.push(pp);
                        // console.log(pos_old);
                        // vertexVec.push(new Vec3(x,y,z));
                        // vertices=[];
                        // const pos=new Vec3(x,y,z);
                        // const rand=new Vec3(rand01(),rand01(),rand01());
                        // pos_old.push(new Vec3(x,y,z) + 0.001 * rand);
                        // const force=new Vec3(0,0,0);
                        // const velocidad=new Vec3(0,0,0);
                        // const sigma=.1;
                        // const beta=0.0;
                        // var p=new Particle();
                        // var y=1;
                        // var z=2;
                        // y+=y*.5;
                        // z+=y*.5;
                        // p.pos=[x,y,z];
                        // var rand=[rand01(),rand01(),rand01()];
                        // p.pos_old=p.pos + 0.001 * rand;
                        // p.force=[0,0,0];
                        // p.velocidad=[0,0,0];
                        // p.sigma=.1;
                        // p.beta=0.0;
                        // // (pos,pos_old,velocidad,force,0,0,0,0,0,sigma,beta,[]);
                        // const pp=p.createParticle();
                        // scene.add(pp);
                        // particles.push(pp);
                        // console.log(pp);
                    }
                }
            }
            // console.log(particles);
        // const p=new Particle();
        // const pp=p.createParticle();
        // scene.add(pp);
        // for(let i=0;i<pos_old.length;i++){

        }
        // const p=new Particle();
        // const pp=p.createParticle();
        // scene.add(pp);
        // }
        inicio()
        function run(){
            for(let i=0;i<particles.length;++i){
                particles[i].pos_old= particles[i].pos;
                particles[i].pos += particles[i].vel;

                particles[i].pos += particles[i].force;

                particles[i].force= new Vec3(0,-G,0);

                particles[i].vel= particles[i].pos - particles[i].pos_old ;

                var max_vel=4.0;
                var vel_mag=particles[i].vel * particles[i].vel;


                if(vel_mag > max_vel*max_vel){
                    particles[i].vel = particles[i].vel * .5;
                }

                if(particles[i].pos.x < -SIM_W) particles[i].force.x -= (particles[i].pos.x - -SIM_W) / 8;
                if(particles[i].pos.x >  SIM_W) particles[i].force.x -= (particles[i].pos.x - SIM_W) / 8;
                if(particles[i].pos.y < bottom) particles[i].force.y -= (particles[i].pos.y - bottom) / 8;
                if(particles[i].pos.y > SIM_W*2)particles[i].force.y -= (particles[i].pos.y - SIM_W*2) / 8;
                particles[i].rho = particles[i].rho_near = 0;
                particles[i].neighbors=[];

            }
            // for(let i=0; i < particles.length; ++i)
            // {
            //     particles[i].rho = particles[i].rho_near = 0;
            //     var d=0,dn=0;

            //     for(let j=0; j < particles.length; ++j){
            //         for(let k=0; k < particles.length;++k){
            //             if(j>=i & k>=j ) continue;

            //             var rijk=particles[j].pos - particles[i].pos - particles[k].pos;
            //             var rijk_len2=rijk * rijk;
            //             if(rijk_len2 < rsq)
            //             {
                            
            //                 var rijk_len = sqrt(rijk_len2);

                            
            //                 var q = 1 - rij_len / r;
            //                 var q2 = q*q;
            //                 var q3 = q2*q;

            //                 d += q2;
            //                 dn += q3;

            //                 // Accumulate on the neighbor
            //                 particles[j].rho += q2;
            //                 particles[j].rho_near += q3;

            //                 // Set up the neighbor list for faster access later.
            //                 n=new Neighbor();
            //                 n.i = i; n.j = j;
            //                 n.q = q; n.q2 = q2;              
            //                 particles[i].neighbors.push_back(n);
            //             }
            //         }
                    
            //     }
            //     particles[i].rho+= d;
            //     particles[i].rho_near+= dn;
            // }

            // for(let i=0;i<particles.lenght;++i){
            //     particles[i].press = k * (particles[i].rho - rest_density);
            //     particles[i].press_near = k_near * particles[i].rho_near;
            // }
            // //--------POSIBLE ERROR-----
            // for(let i=0;i< particles.lenght;++i){
            //     dx= Vec3();

            //     ncount= particles[i].neighbors.lenght;
            //     for(let ni=0;ni< ncount;++ni){
            //         var n=new Neighbor();
            //         var n=particles[i].neighbors[ni];
            //         var j=n.j;
            //         var q=n.q;
            //         var q2= n.q2;
            //         rijk=particles[j].pos - particles[i].pos ;

            //         dm=(particles[i].press + particles[j].press )*q + (particles[i].press_near+ particles[j].press_near)*q2;

            //         dw=rijk.normal()*dm;
            //         dX +=dw;
            //         particles[j].force+=dw;
            //     }
            //     particles[i].force -= dX
            // }
            // for(let i=0; i < particles.length; ++i){
            //     for(let ni=0; ni < particles[i].neighbors.lenght; ++ni){
            //         var n = particles[i].neighbors[ni];
            //         var rijk = particles[n.j].pos - particles[i].pos ;

            //     }
            // }
        }
        // const pos=new Vec3(1,1,1);
        // const rand=new Vec3(rand01(),rand01(),rand01());
        // const pos_old=pos + 0.001 * rand;
        // const force=new Vec3(0,0,0);
        // const velocidad=new Vec3(0,0,0);
        // const sigma=.1;
        // const beta=0.0;
        // const p=new Particle(pos,pos_old,velocidad,force,0,0,0,0,0,sigma,beta,[]);
        //             // (pos,pos_old,velocidad,force,0,0,0,0,0,sigma,beta,[]);
        // const pp=p.createParticle();
        //             // scene.add(pp);
        // particles.push(pp);
        // console.log(pp);
        

        // class Planeta{
        //     constructor(nombrePlaneta,radio,orbita,velocidad,texturas){
        //         this.nombrePlaneta=nombrePlaneta;
        //         this.radio=radio;
        //         this.orbita=orbita;
        //         this.velocidad=velocidad;
        //         this.texturas=texturas;
                
        //     }
        //     crearPlaneta(){
        //         var geometry_sphere= new  THREE.SphereGeometry(this.radio, 32, 16);
        //         var textura_planeta= new THREE.TextureLoader().load(this.texturas)
        //         var mat = new THREE.MeshBasicMaterial({map: textura_planeta});//wireframe: true
        //         var planeta=new THREE.Mesh(geometry_sphere, mat);
        //         // planeta.position.set(10,10,0);
        //         planeta.userData.orbit=this.orbita;
        //         planeta.userData.speed=this.velocidad;
        //         return planeta;
        //     }
        //     moveinOrbit(){
        //         // const shape = new THREE.Shape();
        //         // shape.moveTo(this.orbita, 0);
        //         // shape.absarc(0, 0, this.orbita, 0, 2 * Math.PI, false);
        //         // console.log(shape);
        //         // var spacedPoints =new THREE.ShapeGeometry(shape,128);
        //         const curva=new THREE.EllipseCurve( 0,0 , this.orbita,this.orbita,0,2 * Math.PI,false,0);
        //         const points=curva.getPoints(128);
        //         var spacedPoints=  new THREE.BufferGeometry().setFromPoints( points );
        //         // var spacedPoints = new THREE.BufferGeometry().setFromPoints(shape,128);
        //         spacedPoints.rotateX(THREE.Math.degToRad(-90));
        //         var orbit = new THREE.Line(spacedPoints, new THREE.LineBasicMaterial({
        //         color: 0xd2cbc4
        //         }));
        //         return orbit;
        //     }
        // }
       
        //posn=i+5*-2
        //posx=posn*4
        //posy=0.25        
        //posz=15
       
        // var planets=[];
        // var timestamp=0;
        // var scaleVector = new THREE.Vector3();
        // var texturas_array=['textures/mercurioMap.jpg','textures/venus.jpg','textures/tierra.jpg','textures/marte.jpg','textures/jupiter.jpg','textures/saturno.jpg','textures/urano.jpg','textures/neptuno.jpg','textures/sol.png'];
        // //PLANETA Mercurio
        // const p1= new Planeta("Mercurio",3,25,4.5,texturas_array[0]);
        // const pp1 = p1.crearPlaneta();
        // scene.add(pp1);
        // scene.add(p1.moveinOrbit());
        // planets.push(pp1);
        
        // //PLANETA Venus
        // const p2= new Planeta("Venus",3.5,35,4.3,texturas_array[1]);
        // const pp2 = p2.crearPlaneta();
        // scene.add(pp2);
        // scene.add(p2.moveinOrbit());
        // planets.push(pp2);
        // //PLANETA Tierra 
        // const p3= new Planeta("Tierra",4,45,3.7,texturas_array[2]);
        // const pp3= p3.crearPlaneta();
        // scene.add(pp3);
        // scene.add(p3.moveinOrbit());
        // planets.push(pp3);
        // //PLANETA Marte
        // const p4= new Planeta("Marte",3.6,55,2,texturas_array[3]);
        // const pp4=p4.crearPlaneta(); 
        // scene.add(pp4);
        // scene.add(p4.moveinOrbit());
        // planets.push(pp4);
        // //PLANETA Jupiter
        // const p5= new Planeta("Jupiter",5,65,0.9,texturas_array[4]);
        // const pp5=p5.crearPlaneta(); 
        // scene.add(pp5);
        // scene.add(p5.moveinOrbit());
        // planets.push(pp5);
        // //PLANETA Saturno
        // const p6= new Planeta("Saturno",5.5,75,0.7,texturas_array[5]);
        // const pp6=p6.crearPlaneta(); 
        // scene.add(pp6);
        // scene.add(p6.moveinOrbit());
        // planets.push(pp6);
        // //PLANETA Urano
        // const p7= new Planeta("Urano",4.4,85,0.5,texturas_array[6]);
        // const pp7=p7.crearPlaneta(); 
        // scene.add(pp7);
        // scene.add(p7.moveinOrbit());
        // planets.push(pp7);
        // //PLANETA Neptuno
        // const p8= new Planeta("Neptuno",4.8,95,0.3,texturas_array[7]);
        // const pp8=p8.crearPlaneta(); 
        // scene.add(pp8);
        // scene.add(p8.moveinOrbit());
        // planets.push(pp8);
        // // console.log(planets[0]);
        // // console.log(planets[1]);
        // // console.log(planets[2]);
        // // console.log(planets[3]);
        // //Sol
        // var materialSun= new THREE.TextureLoader().load(texturas_array[8]);
        // var sun = new THREE.Mesh(new THREE.SphereGeometry(10, 32, 16), new THREE.MeshBasicMaterial({map: materialSun}));
        // scene.add(sun);

       
        
        ////////////////////////////////////////////////////////////
        // HemisphereLight light ///////////////////////////////////
        const skyColor = 0x001e0f;  // light blue
        const groundColor = 0x59340B;  // black
        const hemisphere_light = new THREE.HemisphereLight(skyColor, groundColor, 0.5);
        scene.add(hemisphere_light);  
        //Load background texture
        const loader = new THREE.TextureLoader();
        loader.load('https://images.pexels.com/photos/1205301/pexels-photo-1205301.jpeg' , function(texture)
        {
            scene.background = texture;  
        });      
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // PISO
        const groundGeometry = new THREE.PlaneGeometry( 65, 65, 10, 10 );
        const groundMaterial = new THREE.MeshBasicMaterial( { color: 0xcccccc, transparent: true, opacity: 0.5} );
        const ground = new THREE.Mesh( groundGeometry, groundMaterial );
        ground.rotation.x = Math.PI * - 0.5;
        ground.position.y=-2;
        scene.add( ground );
        // PARED
        const cubeGeometry1 = new THREE.PlaneGeometry( 65, 65, 10, 10 );
        const groundMaterial1 = new THREE.MeshBasicMaterial( { color: 0xcccccc, transparent: true, opacity: 0.5} );
        const pared1 = new THREE.Mesh( cubeGeometry1, groundMaterial1 );
        pared1.rotation.z = Math.PI /2;
        pared1.position.z=-32.5;
        pared1.position.y=30;
        scene.add( pared1 );

        const cubeGeometry2 = new THREE.PlaneGeometry( 65, 65, 10, 10 );
        const groundMaterial2 = new THREE.MeshBasicMaterial( { color: 0xcccccc, transparent: true, opacity: 0.5} );
        const pared2 = new THREE.Mesh( cubeGeometry2, groundMaterial2 );
        pared2.rotation.z = Math.PI /2;
        pared2.position.z=32.5;
        pared2.position.y=30;
        scene.add( pared2 );

        const cubeGeometry3 = new THREE.PlaneGeometry( 65, 65, 10, 10 );
        const groundMaterial3 = new THREE.MeshBasicMaterial( { color: 0xcccccc, transparent: true, opacity: 0.5} );
        const pared3 = new THREE.Mesh( cubeGeometry3, groundMaterial3 );
        pared3.rotation.y = Math.PI /2;
        pared3.position.x=-32.5;
        pared3.position.y=30;
        scene.add( pared3 );
        ////////////////////////////////////////////////////////////
        // DirectionalLight  ///////////////////////////////////////
        const color = 0xFFFFFF;
        const intensity = 0.5;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(5, 10, 10);
        light.target.position.set(0, 0, 0);
        scene.add(light);
        scene.add(light.target);

        const helper = new THREE.DirectionalLightHelper(light);
        scene.add(helper);

        function updateLight() {
            light.target.updateMatrixWorld();
            helper.update();
        }
        updateLight();        
        // gui
        // const gui = new GUI();
        // gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
        // gui.add(light, 'intensity', 0, 2, 0.01);
        // makeXYZGUI(gui, light.position, 'position', updateLight);
        // makeXYZGUI(gui, light.target.position, 'target', updateLight); 
        //////////////////////////////////////////////////////////// 
        ////////////////////////////////////////////////////////////

        
        // renderer //////////////////////////////////////////////////
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        renderer.render( scene, camera );
        
        // OrbitControls /////////////////////////////////////////////
        var controls = new OrbitControls( camera, renderer.domElement );
        
        // axes ///////////////////////////////////////////////////////
        const axesHelper = new THREE.AxesHelper( 100 );
        scene.add( axesHelper );
                
        // animation //////////////////////////////////////////////////
        var animate = function(){
            // timestamp = Date.now() * 0.0001;
            var vecNeighnor=[];
            requestAnimationFrame(animate);
            particles.forEach(function(particula){
                // var c1 = .1 * particula.userData.rho;
                // var x1 = 20 * Math.abs(particula.userData.speed.x);
                // var y1 = 20 * Math.abs(particula.userData.speed.y);
                // var z1= 20*Math.abs(particula.userData.speed.z);
                // // var colorC=new THREE.Color("rgb(x1,y1,z1)")
                // particula.material.color.setRGB(.3+x1,.3+y1,.3+c1);
                var velocidad=particula.userData.speed;
                var old_pos=particula.userData.pos_old;
                // var velocidad=particula.userData.speed;
                particula.userData.pos_old.x=particula.position.x;
                particula.userData.pos_old.y=particula.position.y;
                particula.userData.pos_old.z=particula.position.z;

                particula.position.x += velocidad.x;
                particula.position.y += velocidad.y;
                particula.position.z += velocidad.z;

                particula.position.x += particula.userData.force.x;
                particula.position.y += particula.userData.force.y;
                particula.position.z += particula.userData.force.z;

                particula.userData.force= new Vec3(0,-G,0);

                particula.userData.speed.x = particula.position.x - old_pos.x ;
                particula.userData.speed.y = particula.position.y - old_pos.y ;
                particula.userData.speed.z = particula.position.z - old_pos.z ;

            //    console.log(particula.userData.force);

               var max_vel=2.0;
               var vel_mag= particula.userData.speed.x * particula.userData.speed.x + 
                            particula.userData.speed.y * particula.userData.speed.y +
                            particula.userData.speed.z * particula.userData.speed.z;

                if(particula.position.x < -SIM_W) particula.userData.force.x -= (particula.position.x - -SIM_W) / 8;
                if(particula.position.x >  SIM_W) particula.userData.force.x -= (particula.position.x - SIM_W) / 8;
                if(particula.position.y < bottom) particula.userData.force.y -= (particula.position.y - bottom) / 8;
                if(particula.position.y > SIM_W*2)particula.userData.force.y -= (particula.position.y - SIM_W*2) / 8;
                if(particula.position.z < -SIM_W) particula.userData.force.z -= (particula.position.z - -SIM_W) / 8;
                if(particula.position.z >  SIM_W) particula.userData.force.z -= (particula.position.z - SIM_W) / 8;



                particula.userData.rho = particula.userData.rho_near = 0;
                particula.userData.neighbors=[];
                // console.log(particula.userData.neighbors);
            });
            // particles.forEach(function(particula){
            //     particula.userData.rho=0;
            //     particula.userData.rho_near=0;
            //     var d=0, dn=0;

            // });
            
            for(let i=0;i<particles.length;++i){
                var cont=0;
                particles[i].userData.rho =0; 
                particles[i].userData.rho_near = 0;
                particles[i].userData.neighbors=new Array();
                var d=0; 
                var dn=0;
                for(let j=0;j<particles.length;++j){
                    if(j >= i) continue;

                    var rij =new Vec3(particles[j].position.x - particles[i].position.x,
                                  particles[j].position.y - particles[i].position.y,
                                  particles[j].position.z - particles[i].position.z);
                    var rij_len3=rij.x*rij.x + rij.y*rij.y + rij.z*rij.z;

                    if(rij_len3<rsq){
                        cont=cont+1;
                        var rij_len=Math.sqrt(rij_len3);
                        var q=1- rij_len/r;
                        var q2=q*q;
                        var q3=q2*q;
                        d+=q2;
                        dn+=q3;

                        particles[j].userData.rho += q2;
                        particles[j].userData.rho_near += q3;
                        // console.log("1");
                        var n=new Neighbor(i,j,q,q2);
                        // console.log(n)
                        // n.i = i; n.j = j;
                        // n.q = q; n.q2 = q2; 
                        // vecNeighnor.push(n);
                        particles[i].userData.neighbors.push(n);
                        // console.log(cont);
                        // console.log(particles[i].neighbors.lenght);
                    }
                    
                }
                vecNeighnor=[];
                particles[i].userData.rho += d;
                particles[i].userData.rho_near += dn;
                // console.log(Object.keys(particles[i].userData.neighbors).length);
               
                // console.log(particles[i].userData.neighbors)
            }
            particles.forEach(function(particula){
                
                particula.userData.press=k* (particula.userData.rho - rest_density);
                particula.userData.press_near=k_near * particula.userData.rho_near;
                // console.log(particula.userData.press_near);
            });
            // for(let i=0;i<particles.lenght;++i){
            //     console.log("as");
            //     particles[i].userData.press=k* (particles[i].userData.rho - rest_density);
            //     particles[i].userData.press_near=k_near * particles[i].userData.rho_near;
            //     // console.log("ma",particles[i].press);
            // }

            for(let i=0;i<particles.length;++i){
                var dx=new Vec3(0,0,0);
                var ncount= Object.keys(particles[i].userData.neighbors).length;
                // console.log(ncount);
                for(let ni=0;ni<ncount;++ni){
                    var n=particles[i].userData.neighbors[ni];
                    var j=n.j;
                    // console.log(j);
                    var q=n.q;
                    
                    var q2=n.q2;
                    // console.log(q2);

                    var rij= new Vec3(particles[j].position.x - particles[i].position.x,
                                      particles[j].position.y - particles[i].position.y,
                                      particles[j].position.z - particles[i].position.z);
                    
                    var dm=(particles[i].userData.press + particles[j].userData.press)*q + 
                           (particles[i].userData.press_near + particles[j].userData.press_near)*q2;
                    
                    var nlen=Math.sqrt(rij.x*rij.x + rij.y*rij.y + rij.z*rij.z);
                    
                    var dw= new Vec3((rij.x/nlen)*dm,(rij.y/nlen)*dm,(rij.z/nlen)*dm);
                    // dw.x=dw.x*dm.x;
                    // dw.y=dw.y*dm.y;
                    // dw.z=dw.z*dm.z;
                    // console.log(dm.x); 

                    dx.x +=dw.x;
                    dx.y +=dw.y;
                    dx.z +=dw.z;
                    // // console.log("aw");
                    particles[j].userData.force.x +=dw.x;
                    particles[j].userData.force.y +=dw.y;
                    particles[j].userData.force.z +=dw.z;
                }
                particles[i].userData.force.x -=dx.x;
                particles[i].userData.force.y -=dx.y;
                particles[i].userData.force.z -=dx.z;
            }
            for(let i=0;i<particles.lenght;++i){
                var ncount=Object.keys(particles[i].userData.neighbors).length;
                for(let ni=0;ni<ncount;++ni){
                    var n= particles[i].userData.neighbors[ni];
                    var rij=new Vec3(particles[n.j].position.x - particles[i].position.x,particles[n.j].position.y - particles[i].position.y,particles[n.j].position.z - particles[i].position.z);
                    var l=Math.sqrt(rij.x*rij.x + rij.y*rij.y + rij.z*rij.z);;
                    var q=l/r;

                    var rijn=new Vec3(rij.x/l,rij.y/l,rij.z/l);

                    var u= (particles[n.i].userData.vel.x - particles[n.j].userData.vel.x)*rijn.x + (particles[n.i].userData.vel.y - particles[n.j].userData.vel.y)*rijn.y + (particles[n.i].userData.vel.z - particles[n.j].userData.vel.z)*rijn.z;
                    if(u>0){
                        var red=(1 - q) * (particles[n.j].userData.sigma * u + particles[n.j].userData.beta * u*u);
                        vI=new Vec3(red*rijn.x,red*rijn.y,red*rijn.z);

                        particles[n.i].userData.vel -= vI * 0.5;
                        particles[n.j].userData.vel += vI * 0.5;
                    }
                }
            }
            // console.log(particles[1].neighbors);
            // console.log(particles[0].neighbors);
            // planets.forEach(function(planeta){
            //     var scaleFactor = 8;
            //     var scale = scaleVector.subVectors(planeta.position, camera.position).length() / scaleFactor;
            //     var orbit = planeta.userData.orbit;
            //     var speed = planeta.userData.speed;
            //     planeta.position.x = Math.cos(timestamp * speed) * orbit;
            //     planeta.position.z = Math.sin(timestamp * speed) * orbit;});
            renderer.render( scene, camera );
        }
        animate();
        

        // redimensioar  /////////////////////////////////////////////
        window.addEventListener('resize', redimensionar);
        function redimensionar(){
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.render( scene, camera );
        }
    </script>    

</body>
</html>